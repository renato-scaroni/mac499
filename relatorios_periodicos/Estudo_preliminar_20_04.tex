\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{parskip}


\title{Relatório de estudos preliminar do TCC}
\author{Renato Scaroni}
% O mês estava em inglês. Coloquei em português
\date{Abril 2014}

\begin{document}


\maketitle

\section{Tema e Motivação}

Esse projeto de conclusão de curso tem por objetivo desenvolver 
% Eu removeria "uma implementação de"
uma implementação de
um protocolo de comunicação de redes utilizando a idéia de redes P2P para uso com a
% Eu colocaria a URL oficial da Game Engine Unity 3D com um \footnote depois do "Game Engine Unity 3D"
Game Engine Unity 3D em rede local. A escolha desse tema deve-se a dois motivos: 
\\
\begin{itemize}
\item A facilidade de uso de uma rede P2P, uma vez que retira a necessidade de uma
estrutura cliente-servidor, ou seja, basta o jogador se conectar na rede local para poder 
se comunicar com os demais jogadores também nela conectados.
\item A ausência de suporte a esse tipo de rede no módulo de \textit{networking} da Unity.
\end{itemize}

% Troquei "Checando" por "Verificando"
\section{Primeiros testes: Verificando viabilidade da implementação}

% Tirei o "complexo" depois de "protocolo"
Antes de começar a escrever um protocolo que implementasse a idéia acima, 
foi preciso realizar pequenos testes a respeito da viabilidade da implementação.
% O português antes estava esquisito. Melhorei. Estava "tem como a implementação de um módulo de rede"
Como o trabalho visa implementar um módulo de rede que utiliza uma abordagem
bem diferente do que já existe implementado na Unity 3D, seria imprescindível saber como
% devices -> dispositivos. Mas talvez o ideal seja processos
realizar a comunicação entre dois ou mais dispositivos rodando o aplicativo em rede local da 
% basica -> básica. Faltou o acento
forma mais básica possível. 
\\\\
Por isso os primeiros testes consistiram em escrever pequenos scripts capazes de enviar
% os protocolos -> o protocolo
e receber pacotes utilizando tanto o protocolo UDP quanto TCP na camada de transporte.
% para a elaboração -> Tirei o "para"
Ambos testes foram bem-sucedidos, de forma que pode-se continuar a elaboração de um
protocolo P2P como desejado. Por isso foram escritos 4 módulos em C\# utilizando como 
base a classe Socket do C\#/Mono, dois módulos pra envio de mensagem (um TCP e um UDP)
e um módulo de recebimento de mensagem (um TCP e um UDP). Todos os testes realizados com
cada um deles foram muito satisfatórios. Foram feitos builds de teste que 
% fora utiliza-dos -> foram utilizados
foram utilizados em máquinas diferentes, com diferentes sistemas operacionais, e tudo funcionou sem
problemas. As máquinas utilizadas foram:

\begin{enumerate}
\item 
\begin{itemize}
% GHZ -> GHz
\item Processador: Intel core 2 duo 2.3 GHz
\item Memória: 4Gb
% Megabit é o fabricante da placa de rede?
\item Placa de rede wifi Megabit
\item Sistema Operacional: Windows 7
\end{itemize}
\item 
\begin{itemize}
\item Processador: Intel core i7
\item Memória: 8Gb
\item Placa de rede wifi Megabit
\item Sistema Operacional: Windows 8
\end{itemize}
\item 
\begin{itemize}
\item Processador: Intel core i7
\item Memória: 8Gb
\item Placa de rede wifi Megabit
\item Sistema Operacional: GNU/Linux Ubuntu 12.10
\end{itemize}
\end{enumerate}

Os programas de teste foram escritos sobre a versão 4.3 da Unity.

\section{Idéia geral do protocolo}
Uma vez com a base construída e funcionando, é hora de pensar em como será o protocolo.
A idéia principal é a seguinte:
\\
\begin{itemize}
\item Quando inicia o programa lança-se uma nova thread que ficará escutando uma porta
% se conectar -> se conectarem
TCP (a ser definida) esperando outros clientes se conectarem. Da mesma forma o programa
disparará um broadcast para todos na sua faixa de IP na rede local avisando que está
conectado. O broadcast será refeito a cada 30 segundos (tempo sujeito a alteração
% de pendendo -> dependendo
dependendo da implementação), apenas para dizer que ainda está vivo.
\item Quando recebe uma mensagem na porta TCP citada no item acima, o programa tomará
% envio -> enviou
a atitude de colocar o peer que a enviou na lista de usuários ativos. Como
% anterior-mente -> anteriormente
dito anterior-
mente, um usuário avisará periodicamente aos demais que continua ativo na rede. Caso, 
após um timeout, ele não se manifeste, será excluído da lista de ativos. Também poderá
haver um tipo de mensagem que avise ao outro que a conexão será encerreda. De acordo com
alguns testes realizados, se o lado de envio encerrar a thread sem avisar ao lado que
escuta para fechá-lo também, isso pode acarretar travamento do programa.
\item Uma vez nas listas um do outro, os jogadores ficam em stand by, esperando por
uma mensagem que signifique começar um novo jogo. Quando isso acontece, se abrem canais
UDP para que um jogador receba mensagens dos outros contendo seus estados atualizados
naquela seção de jogo.
\item O jogo deve sempre guardar o estado de cada outro jogador conectado e apenas
alterá-lo quando receber um pacote pelo socket UDP correspondente.
\end{itemize}

\section{Questões a serem discutidas antes da implementação}
% idéia -> ideia (não tem mais acento depois da revisão do português recente. Inclusive é importante verificar se tem alguma opção de fazer correção ortográfica de português aqui no sharelatex. Caso não tenha recomendo vc copiar e colar o arquivo no seu computador e fazer a correção localmente)
Apesar de termos uma ideia de como o protocolo será estruturado existem algumas questões
importantes a serem definidas durante a implementação e é nisso que deve se concentrar o
trabalho por enquanto, são elas:
\begin{itemize}
\item Como definir uma seção de jogo? Quais jogadores da lista de peers conectados 
% fará -> farão
fará parte do jogo? Deve ser possível escolher quem será convidado?
\item Como definir de forma generalizada o que compõe um estado de um jogador?
\item Como garantir que uma mensagem enviada por um usuário seja mesmo dele?
Devemos usar criptografia assimétrica para isso ou há um modo mais simples?
\item Quando o jogo termina os canais de comunicação UDP se fecham?
\end{itemize}

\end{document}
